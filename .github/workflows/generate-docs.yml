name: Generate API Documentation

on:
  push:
    branches: [ main, dev ]
    paths: ['**/*.py']

permissions:
  contents: write

jobs:
  generate-docs:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'
        cache: 'pip'
    
    - name: Cache pip packages
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('pyproject.toml') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    
    - name: Install build dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential g++ make
    
    - name: Install package (will compile C++ automatically)
      run: |
        pip install -e .
    
    - name: Generate API documentation
      run: |
        python << 'EOF'
        import inspect
        import importlib
        import pkgutil
        import tmg_hmc
        import ast
        import re
        from pathlib import Path

        # ============================================================
        # CONFIGURE MODULES HERE - Edit this list to control order
        # Set to None to auto-discover all modules
        # ============================================================
        MODULES_TO_DOCUMENT = [
            'tmg_hmc',
            'tmg_hmc.constraints',
            'tmg_hmc.utils',
            'tmg_hmc.quadratic_solns',
        ]
        # ============================================================

        def clean_docstring(docstring):
            """Clean and format docstring for markdown display."""
            if not docstring:
                return None
            
            cleaned = inspect.cleandoc(docstring)
            lines = cleaned.split('\n')
            result = []
            
            for i, line in enumerate(lines):
                if line.strip() == '':
                    result.append('')
                else:
                    stripped = line.lstrip()
                    leading_spaces = len(line) - len(stripped)
                    
                    if leading_spaces > 0:
                        indent = '&nbsp;' * (leading_spaces * 2)
                        line_content = f'{indent}{stripped}'
                    else:
                        line_content = stripped
                    
                    if i < len(lines) - 1 and lines[i + 1].strip() != '':
                        line_content += '<br>'
                    
                    result.append(line_content)
            
            return '\n'.join(result)

        def get_source_defaults(func):
            """Extract default values from source code, preserving expressions."""
            try:
                source = inspect.getsource(func)
                tree = ast.parse(source)
                
                for node in ast.walk(tree):
                    if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                        defaults_dict = {}
                        args = node.args
                        
                        # Handle positional defaults
                        num_defaults = len(args.defaults)
                        if num_defaults > 0:
                            default_offset = len(args.args) - num_defaults
                            for i, default in enumerate(args.defaults):
                                arg_name = args.args[default_offset + i].arg
                                defaults_dict[arg_name] = ast.unparse(default)
                        
                        # Handle keyword-only defaults
                        for i, default in enumerate(args.kw_defaults):
                            if default is not None:
                                arg_name = args.kwonlyargs[i].arg
                                defaults_dict[arg_name] = ast.unparse(default)
                        
                        return defaults_dict
            except Exception as e:
                print(f"Warning: Could not parse source for {func.__name__}: {e}")
            return {}

        def format_default(default, param_name=None, source_defaults=None):
            """Format default parameter values, preferring source representation."""
            # ALWAYS try source defaults first
            if source_defaults and param_name and param_name in source_defaults:
                source_val = source_defaults[param_name]
                source_val = source_val.replace('numpy.', 'np.')
                return source_val
            
            if default == inspect.Parameter.empty:
                return None
            
            if default is None:
                return 'None'
            if isinstance(default, bool):
                return str(default)
            if isinstance(default, str):
                return f'"{default}"'
            
            # Fallback for numerical values - try to detect common constants
            if isinstance(default, float):
                import math
                if abs(default - math.pi) < 1e-10:
                    return 'np.pi'
                elif abs(default - math.pi / 2) < 1e-10:
                    return 'np.pi / 2'
                elif abs(default - 2 * math.pi) < 1e-10:
                    return '2 * np.pi'
                elif abs(default - math.e) < 1e-10:
                    return 'np.e'
                elif default == float('inf'):
                    return 'np.inf'
                elif default == float('-inf'):
                    return '-np.inf'
                else:
                    return repr(default)
            
            if isinstance(default, int):
                return repr(default)
            
            try:
                return repr(default)
            except:
                return '...'

        def clean_signature(func):
            """Format function signature."""
            try:
                sig = inspect.signature(func)
                source_defaults = get_source_defaults(func)
                params = []
                
                for param_name, param in sig.parameters.items():
                    if param_name == 'self':
                        continue
                    
                    param_str = param_name
                    
                    if param.annotation != inspect.Parameter.empty:
                        try:
                            annotation = param.annotation.__name__
                        except:
                            annotation = str(param.annotation)
                        annotation = annotation.replace('typing.', '')
                        param_str += f': {annotation}'
                    
                    default_str = format_default(param.default, param_name, source_defaults)
                    if default_str is not None:
                        param_str += f' = {default_str}'
                    
                    params.append(param_str)
                
                return_annotation = ''
                if sig.return_annotation != inspect.Signature.empty:
                    ret_ann = str(sig.return_annotation)
                    ret_ann = ret_ann.replace('typing.', '')
                    return_annotation = f' -> {ret_ann}'
                
                return f'({", ".join(params)}){return_annotation}'
            except (ValueError, TypeError) as e:
                print(f"Warning: Could not get signature: {e}")
                return '(...)'

        def clean_constructor_signature(func, class_name):
            """Format constructor signature."""
            try:
                sig = inspect.signature(func)
                source_defaults = get_source_defaults(func)
                params = []
                
                for param_name, param in sig.parameters.items():
                    if param_name == 'self':
                        continue
                    
                    param_str = param_name
                    
                    if param.annotation != inspect.Parameter.empty:
                        try:
                            annotation = param.annotation.__name__
                        except:
                            annotation = str(param.annotation)
                        annotation = annotation.replace('typing.', '')
                        param_str += f': {annotation}'
                    
                    default_str = format_default(param.default, param_name, source_defaults)
                    if default_str is not None:
                        param_str += f' = {default_str}'
                    
                    params.append(param_str)
                
                return f'{class_name}({", ".join(params)})'
            except (ValueError, TypeError):
                return f'{class_name}(...)'

        def document_class(cls, class_name):
            """Document a class with its methods."""
            docs = []
            
            docs.append(f'## `{class_name}` (class)')
            docs.append('')
            
            # Add constructor signature
            if hasattr(cls, '__init__'):
                try:
                    constructor_sig = clean_constructor_signature(cls.__init__, class_name)
                    docs.append('```python')
                    docs.append(constructor_sig)
                    docs.append('```')
                    docs.append('')
                except (AttributeError, TypeError):
                    docs.append('```python')
                    docs.append(f'{class_name}(...)')
                    docs.append('```')
                    docs.append('')
            
            # Handle docstrings
            class_docstring = clean_docstring(cls.__doc__)
            init_docstring = None
            if hasattr(cls, '__init__'):
                init_docstring = clean_docstring(cls.__init__.__doc__)
            
            if class_docstring and init_docstring:
                docs.append(class_docstring)
                docs.append('')
                docs.append('**Constructor:**')
                docs.append('')
                docs.append(init_docstring)
                docs.append('')
            elif class_docstring:
                docs.append(class_docstring)
                docs.append('')
            elif init_docstring:
                docs.append(init_docstring)
                docs.append('')
            else:
                docs.append('*No description available.*')
                docs.append('')
            
            # Document public methods
            methods = []
            for method_name in dir(cls):
                if not method_name.startswith('_'):
                    try:
                        method = getattr(cls, method_name)
                        if callable(method) and method.__doc__:
                            sig = clean_signature(method)
                            cleaned_method_doc = clean_docstring(method.__doc__)
                            if cleaned_method_doc:
                                methods.append(f'### `{method_name}`')
                                methods.append('')
                                methods.append('```python')
                                methods.append(f'{method_name}{sig}')
                                methods.append('```')
                                methods.append('')
                                methods.append(cleaned_method_doc)
                                methods.append('')
                    except (AttributeError, TypeError):
                        continue
            
            if methods:
                docs.append('### Methods')
                docs.append('')
                docs.extend(methods)
            
            return docs

        def document_module(module, module_name):
            """Document a module."""
            docs = []
            is_top_level = module_name == 'tmg_hmc'
            
            # Use __all__ if available
            if hasattr(module, '__all__'):
                names_to_document = module.__all__
            else:
                names_to_document = [name for name in dir(module) if not name.startswith('_')]
            
            for name in names_to_document:
                if hasattr(module, name):
                    obj = getattr(module, name)
                    
                    # Skip objects from other packages
                    if hasattr(obj, '__module__'):
                        obj_module = obj.__module__
                        if not obj_module.startswith('tmg_hmc'):
                            continue
                        if not is_top_level and obj_module != module.__name__:
                            continue
                    
                    if inspect.isclass(obj):
                        class_docs = document_class(obj, name)
                        docs.extend(class_docs)
                    elif callable(obj) and obj.__doc__:
                        sig = clean_signature(obj)
                        cleaned_func_doc = clean_docstring(obj.__doc__)
                        if cleaned_func_doc:
                            docs.append(f'## `{name}`')
                            docs.append('')
                            docs.append('```python')
                            docs.append(f'{name}{sig}')
                            docs.append('```')
                            docs.append('')
                            docs.append(cleaned_func_doc)
                            docs.append('')
            
            return docs

        # Get package version
        package_version = getattr(tmg_hmc, '__version__', 'unknown')

        # Generate documentation
        all_docs = []
        all_docs.append('# API Reference')
        all_docs.append('')
        all_docs.append(f'> **Package:** `tmg_hmc` v{package_version}')
        all_docs.append('>')
        all_docs.append('> This package implements exact HMC sampling for truncated multivariate gaussians with quadratic constraints.')
        all_docs.append('')

        for modname in MODULES_TO_DOCUMENT:
            try:
                module = importlib.import_module(modname)
                
                if modname == 'tmg_hmc':
                    pass
                else:
                    all_docs.append('---')
                    all_docs.append('')
                    module_display = modname.replace('tmg_hmc.', '').replace('_', ' ').title()
                    all_docs.append(f'# {module_display} Module')
                    all_docs.append('')
                
                module_docs = document_module(module, modname)
                all_docs.extend(module_docs)
                
            except Exception as e:
                print(f"Warning: Could not document {modname}: {e}")

        with open('API_DOCS.md', 'w') as f:
            f.write('\n'.join(all_docs))
        
        print("Documentation generated successfully!")
        EOF
    
    - name: Commit documentation
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add API_DOCS.md
        git diff --quiet && git diff --staged --quiet || git commit -m "Update API documentation [skip ci]"
    
    - name: Push changes
      if: github.event_name == 'push' || github.event_name == 'release'
      uses: ad-m/github-push-action@master
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        branch: ${{ github.ref }}