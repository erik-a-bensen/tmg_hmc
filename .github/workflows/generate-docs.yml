name: Generate API Documentation

on:
  push:
    branches: [ main, dev ]
  pull_request:
    branches: [ main, dev ]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  generate-docs:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'
        cache: 'pip'
    
    - name: Cache pip packages
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('pyproject.toml') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    
    - name: Install build dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential g++ make
    
    - name: Install package (will compile C++ automatically)
      run: |
        pip install -e .
    
    - name: Generate API documentation
      run: |
        python << 'EOF'
        import inspect
        import importlib
        import pkgutil
        import tmg_hmc
        import ast
        from pathlib import Path

        # ============================================================
        # CONFIGURE MODULES HERE - Edit this list to control order
        # Set to None to auto-discover all modules
        # ============================================================
        MODULES_TO_DOCUMENT = [
            'tmg_hmc',
            'tmg_hmc.constraints',
            'tmg_hmc.utils',
            'tmg_hmc.quadratic_solns',
            # Add more modules here in the order you want them documented
        ]
        # Set to None to auto-discover:
        # MODULES_TO_DOCUMENT = None
        # ============================================================

        def get_source_defaults(func):
            """Extract default values from source code to preserve expressions like np.pi."""
            try:
                source = inspect.getsource(func)
                tree = ast.parse(source)
                
                # Find the function definition
                for node in ast.walk(tree):
                    if isinstance(node, ast.FunctionDef):
                        defaults_dict = {}
                        
                        # Get the arguments
                        args = node.args
                        
                        # Match defaults with argument names
                        num_defaults = len(args.defaults)
                        if num_defaults > 0:
                            # Defaults are aligned to the right of args
                            default_offset = len(args.args) - num_defaults
                            for i, default in enumerate(args.defaults):
                                arg_name = args.args[default_offset + i].arg
                                defaults_dict[arg_name] = ast.unparse(default)
                        
                        # Handle keyword-only defaults
                        for i, default in enumerate(args.kw_defaults):
                            if default is not None:
                                arg_name = args.kwonlyargs[i].arg
                                defaults_dict[arg_name] = ast.unparse(default)
                        
                        return defaults_dict
            except:
                pass
            return {}

        def format_default(default, param_name=None, source_defaults=None):
            """Format default parameter values without evaluating numerical constants."""
            # Try to get the original source representation first
            if source_defaults and param_name in source_defaults:
                return source_defaults[param_name]
            
            if default == inspect.Parameter.empty:
                return None
            
            # Handle None
            if default is None:
                return 'None'
            
            # Handle booleans
            if isinstance(default, bool):
                return str(default)
            
            # Handle strings
            if isinstance(default, str):
                return f'"{default}"'
            
            # Handle numbers - check if it's a known constant
            if isinstance(default, float):
                import math
                # Check for common constants
                if abs(default - math.pi) < 1e-10:
                    return 'np.pi'
                elif abs(default - math.e) < 1e-10:
                    return 'np.e'
                elif default == float('inf'):
                    return 'np.inf'
                elif default == float('-inf'):
                    return '-np.inf'
                else:
                    return repr(default)
            
            if isinstance(default, int):
                return repr(default)
            
            # For everything else, try to get a reasonable representation
            try:
                return repr(default)
            except:
                return '...'

        def format_signature(sig, func=None):
            """Format signature to be more readable."""
            # Get source defaults if available
            source_defaults = {}
            if func is not None:
                source_defaults = get_source_defaults(func)
            
            params = []
            for name, param in sig.parameters.items():
                if name == 'self':
                    continue
                
                # Get type annotation if available
                annotation = ''
                if param.annotation != inspect.Parameter.empty:
                    try:
                        annotation = f': {param.annotation.__name__}'
                    except:
                        annotation = ''
                
                # Get default value
                default_str = format_default(param.default, name, source_defaults)
                
                if default_str is None:
                    params.append(f"{name}{annotation}")
                else:
                    params.append(f"{name}{annotation}={default_str}")
            
            return f"({', '.join(params)})"

        def document_module(module, f, module_name):
            """Document all classes and functions in a module."""
            documented_items = []
            
            # Check if this is the top-level package
            is_top_level = module_name == 'tmg_hmc'
            
            # Get all members of the module
            for name, obj in inspect.getmembers(module):
                # Skip private members
                if name.startswith('_'):
                    continue
                
                # Skip imports from other packages (not tmg_hmc)
                if hasattr(obj, '__module__'):
                    obj_module = obj.__module__
                    if not obj_module.startswith('tmg_hmc'):
                        continue
                    
                    # For non-top-level modules, only document items defined in that specific module
                    if not is_top_level and obj_module != module.__name__:
                        continue
                
                # Document functions
                if inspect.isfunction(obj):
                    try:
                        sig = inspect.signature(obj)
                        formatted_sig = format_signature(sig, obj)
                        f.write(f'### `{name}{formatted_sig}`\n\n')
                        if obj.__doc__:
                            f.write(f'{obj.__doc__}\n\n')
                        else:
                            f.write('*No documentation available.*\n\n')
                        documented_items.append(name)
                    except (ValueError, TypeError):
                        pass
                
                # Document classes
                elif inspect.isclass(obj):
                    f.write(f'### Class: `{name}`\n\n')
                    if obj.__doc__:
                        f.write(f'{obj.__doc__}\n\n')
                    else:
                        f.write('*No documentation available.*\n\n')
                    
                    # Document class methods
                    methods_documented = []
                    for method_name, method in inspect.getmembers(obj, predicate=inspect.isfunction):
                        if method_name.startswith('_') and method_name != '__init__':
                            continue
                        try:
                            sig = inspect.signature(method)
                            formatted_sig = format_signature(sig, method)
                            f.write(f'#### `{method_name}{formatted_sig}`\n\n')
                            if method.__doc__:
                                f.write(f'{method.__doc__}\n\n')
                            else:
                                f.write('*No documentation available.*\n\n')
                            methods_documented.append(method_name)
                        except (ValueError, TypeError):
                            pass
                    
                    documented_items.append(name)
            
            return documented_items

        with open('API_DOCS.md', 'w') as f:
            f.write('# TMG HMC API Documentation\n\n')
            f.write('**Package:** `tmg_hmc` v0.0.2\n\n')
            f.write('**Description:** This package implements exact HMC sampling for truncated multivariate gaussians with quadratic constraints.\n\n')
            f.write('---\n\n')
            f.write('## Table of Contents\n\n')
            
            # Determine which modules to document
            if MODULES_TO_DOCUMENT is None:
                # Auto-discover all submodules
                package_path = Path(tmg_hmc.__file__).parent
                modules_info = []
                for importer, modname, ispkg in pkgutil.walk_packages([str(package_path)], prefix='tmg_hmc.'):
                    if not modname.startswith('tmg_hmc._'):  # Skip private modules
                        modules_info.append(modname)
                modules_info = sorted(modules_info)
            else:
                # Use manually specified modules
                modules_info = MODULES_TO_DOCUMENT
            
            # Write table of contents
            for modname in modules_info:
                module_display = modname.replace('tmg_hmc.', '') if modname != 'tmg_hmc' else 'tmg_hmc (main)'
                anchor = modname.replace('.', '')
                f.write(f'- [{module_display}](#{anchor})\n')
            
            f.write('\n---\n\n')
            
            # Document each module
            for modname in modules_info:
                try:
                    module = importlib.import_module(modname)
                    module_display = modname.replace('tmg_hmc.', '') if modname != 'tmg_hmc' else 'tmg_hmc (main)'
                    
                    f.write(f'## {module_display}\n\n')
                    
                    if module.__doc__:
                        f.write(f'{module.__doc__}\n\n')
                    
                    documented = document_module(module, f, modname)
                    
                    if not documented:
                        f.write('*No public API documented.*\n\n')
                    
                    f.write('---\n\n')
                    
                except Exception as e:
                    print(f"Warning: Could not document {modname}: {e}")
        
        print("Documentation generated successfully!")
        EOF
    
    - name: Commit documentation
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add API_DOCS.md
        git diff --quiet && git diff --staged --quiet || git commit -m "Update API documentation [skip ci]"
    
    - name: Push changes
      if: github.event_name == 'push'
      uses: ad-m/github-push-action@master
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        branch: ${{ github.ref }}